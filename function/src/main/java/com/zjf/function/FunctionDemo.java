package com.zjf.function;import java.util.function.Function;public class FunctionDemo {//    0、@FunctionalInterface//    所有用这个注解声明的借口都是函数式接口。具体来说，所有标注了该注解的接口都将能用在lambda表达式上。//    1、R apply(T t);//    t调用 function 中的函数表达式，获取一个新的值。相当于进入一个黑盒子。//    2、default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {//        Objects.requireNonNull(before);//        return (V v) -> apply(before.apply(v));//    }//    compose接收一个Function参数，返回时先用传入的逻辑执行apply，然后使用当前Function的apply。//    compose等价于B.apply(A.apply(5))//    3、default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {//        Objects.requireNonNull(after);//        return (T t) -> after.apply(apply(t));//    }//    andThen跟compose正相反，先执行当前的逻辑，再执行传入的逻辑。//    andThen等价于A.apply(B.apply(5))//    4、static <T> Function<T, T> identity() {//        return t -> t;//    }    public static void main(String[] args) {        Function<Integer, Integer> A = i -> i + 1;        Function<Integer, Integer> B = i -> i * i;        System.out.println("F1:" + B.apply(A.apply(5)));        System.out.println("F1:" + B.compose(A).apply(5));        System.out.println("F2:" + A.apply(B.apply(5)));        System.out.println("F2:" + B.andThen(A).apply(5));    }}